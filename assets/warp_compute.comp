#version 430 core

layout (local_size_x = 10, local_size_y = 10, local_size_z = 1) in;

layout(rgba8, binding = 0) uniform image2D samplerImage;
layout(rgba8, binding = 1) uniform image2D image;
layout(std430, binding = 2) buffer Points
{
	int ps[4 * 2];
};

layout (location = 3) uniform mat3 warp;
layout (location = 4) uniform bool doWarp;
layout (location = 5) uniform bool doLines;

void drawLine(vec2 p1, vec2 p2) {
    bool steep = abs(p2.y - p1.y) > abs(p2.x - p1.x);
    if (steep)
    {
        p1 = vec2(p1.y, p1.x);
        p2 = vec2(p2.y, p2.x);
    }
    if (p1.x > p2.x)
    {
        vec2 temp = p1;
        p1 = p2;
        p2 = temp;
    }
    vec2 d = p2 - p1;
    float error = d.x / 2.0;
    float ystep = (p1.y < p2.y) ? 1.0 : -1.0;
    float y = p1.y;
    
    bool flip = true;
    
    for (float x = p1.x; x <= p2.x; x += 1.0)
    {
        if(int(x) % 5 == 0)
			flip = !flip;
        
        if (steep)
            imageStore(image, ivec2(y, x), flip ? vec4(255, 255, 255, 255) : vec4(0, 0, 0, 255));
        else
            imageStore(image, ivec2(x, y), flip ? vec4(255, 255, 255, 255) : vec4(0, 0, 0, 255));

        error -= abs(d.y);
        if (error < 0.0)
        {
            y += ystep;
            error += d.x;
        }
    }
}

void main() 
{
	ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);
    
    if(doWarp)
    {
        float in_x = warp[0][0] * texelCoord.x + warp[0][1] * texelCoord.y + warp[0][2];
        float in_y = warp[1][0] * texelCoord.x + warp[1][1] * texelCoord.y + warp[1][2];
        float in_z = warp[2][0] * texelCoord.x + warp[2][1] * texelCoord.y + warp[2][2];

        int x_norm = int(in_x / in_z);
        int y_norm = int(in_y / in_z);

        imageStore(image, texelCoord, vec4(255, 255, 255, 255));
        imageStore(image, texelCoord, imageLoad(samplerImage, ivec2(x_norm, y_norm)));
    }
    else
    {
        imageStore(image, texelCoord, imageLoad(samplerImage, texelCoord));
    }
    
    if(doLines)
    {
        if(texelCoord.x == 0 && texelCoord.y == 0)
        {
            drawLine(vec2(ps[0], ps[1]), vec2(ps[2], ps[3]));
            drawLine(vec2(ps[0], ps[1]), vec2(ps[6], ps[7]));
            drawLine(vec2(ps[2], ps[3]), vec2(ps[4], ps[5]));
            drawLine(vec2(ps[4], ps[5]), vec2(ps[6], ps[7]));
            
        }
    }
}