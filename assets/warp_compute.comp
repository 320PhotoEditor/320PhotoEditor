#version 430 core

layout (local_size_x = 10, local_size_y = 10, local_size_z = 1) in;

layout(rgba8, binding = 0) uniform image2D samplerImage;
layout(rgba8, binding = 1) uniform image2D image;
layout(std430, binding = 2) buffer Points
{
	int ps[4 * 2];
};

layout (location = 3) uniform mat3 warp;

void drawLine(int x1, int y1, int x2, int y2)
{
    int dx = abs(x2 - x1);
    int dy = abs(y2 - y1);
    int sx = x1 < x2 ? 1 : -1;
    int sy = y1 < y2 ? 1 : -1;
    int err = dx - dy;

	bool flip = true;
	int counter = 0;
	

    while (true)
    {
		counter++;
		if(counter % 5 == 0)
			flip = !flip;
        imageStore(image, ivec2(x1, y1), flip ? vec4(255, 255, 255, 255) : vec4(0, 0, 0, 255));

        if (x1 == x2 && y1 == y2)
        {
            break;
        }

        int e2 = 2 * err;

        if (e2 > -dy)
        {
            err -= dy;
            x1 += sx;
        }

        if (e2 < dx)
        {
            err += dx;
            y1 += sy;
        }
    }
}

ivec2 transformPoint(ivec2 p, mat3 transformM)
{
    float x = p.x * transformM[0][0] + p.y * transformM[1][0] + transformM[2][0];
	float y = p.x * transformM[0][1] + p.y * transformM[1][1] + transformM[2][1];
    return ivec2(int(x), int(y));
}

void main() 
{
	ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);

	imageStore(image, texelCoord, imageLoad(samplerImage, texelCoord));

    imageStore(image, transformPoint(texelCoord, warp), imageLoad(samplerImage, texelCoord));

	if(texelCoord.x == 0 && texelCoord.y == 0)
	{
        drawLine(ps[0], ps[1], ps[2], ps[3]);
        drawLine(ps[0], ps[1], ps[4], ps[5]);
        drawLine(ps[2], ps[3], ps[6], ps[7]);
        drawLine(ps[4], ps[5], ps[6], ps[7]);
		
	}
}