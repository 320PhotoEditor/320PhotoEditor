#version 430 core

layout (local_size_x = 10, local_size_y = 10, local_size_z = 1) in;

layout(rgba8, binding = 0) uniform image2D samplerImage;
layout(rgba8, binding = 1) uniform image2D image;
layout(std430, binding = 2) buffer Points
{
	int ps[4 * 2];
};

layout (location = 3) uniform mat3 warp;

void drawLine(vec2 p1, vec2 p2) {
    bool steep = abs(p2.y - p1.y) > abs(p2.x - p1.x);
    if (steep)
    {
        p1 = vec2(p1.y, p1.x);
        p2 = vec2(p2.y, p2.x);
    }
    if (p1.x > p2.x)
    {
        vec2 temp = p1;
        p1 = p2;
        p2 = temp;
    }
    vec2 d = p2 - p1;
    float error = d.x / 2.0;
    float ystep = (p1.y < p2.y) ? 1.0 : -1.0;
    float y = p1.y;
    
    bool flip = true;
    
    for (float x = p1.x; x <= p2.x; x += 1.0)
    {
        if(int(x) % 5 == 0)
			flip = !flip;
        
        if (steep)
            imageStore(image, ivec2(y, x), flip ? vec4(255, 255, 255, 255) : vec4(0, 0, 0, 255));
        else
            imageStore(image, ivec2(x, y), flip ? vec4(255, 255, 255, 255) : vec4(0, 0, 0, 255));

        error -= abs(d.y);
        if (error < 0.0)
        {
            y += ystep;
            error += d.x;
        }
    }
}

ivec2 transformPoint(ivec2 p, mat3 transformM)
{
    float x = p.x * transformM[0][0] + p.y * transformM[1][0] + transformM[2][0];
	float y = p.x * transformM[0][1] + p.y * transformM[1][1] + transformM[2][1];
    return ivec2(int(x), int(y));
}

void main() 
{
	ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);

	imageStore(image, texelCoord, imageLoad(samplerImage, texelCoord));

    imageStore(image, transformPoint(texelCoord, warp), imageLoad(samplerImage, texelCoord));

	if(texelCoord.x == 0 && texelCoord.y == 0)
	{
        drawLine(vec2(ps[0], ps[1]), vec2(ps[2], ps[3]));
        drawLine(vec2(ps[0], ps[1]), vec2(ps[4], ps[5]));
        drawLine(vec2(ps[2], ps[3]), vec2(ps[6], ps[7]));
        drawLine(vec2(ps[4], ps[5]), vec2(ps[6], ps[7]));
		
	}
}