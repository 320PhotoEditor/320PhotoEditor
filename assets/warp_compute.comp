#version 430 core

layout (local_size_x = 10, local_size_y = 10, local_size_z = 1) in;

layout(rgba8, binding = 0) uniform image2D samplerImage;
layout(rgba8, binding = 1) uniform image2D image;
layout(std430, binding = 2) buffer Points
{
	int ps[4 * 2];
};

layout (location = 3) uniform mat3 warp;
layout (location = 4) uniform bool doWarp;
layout (location = 5) uniform bool doLines;
layout (location = 6) uniform bool fillTransparent;
layout (location = 7) uniform int dashSize;

void drawLine(vec2 p1, vec2 p2) {
    bool steep = abs(p2.y - p1.y) > abs(p2.x - p1.x);
    if (steep)
    {
        p1 = vec2(p1.y, p1.x);
        p2 = vec2(p2.y, p2.x);
    }
    if (p1.x > p2.x)
    {
        vec2 temp = p1;
        p1 = p2;
        p2 = temp;
    }
    vec2 d = p2 - p1;
    float error = d.x / 2.0;
    float ystep = (p1.y < p2.y) ? 1.0 : -1.0;
    float y = p1.y;
    
    bool flip = true;
    
    for (float x = p1.x; x <= p2.x; x += 1.0)
    {
        if(int(x) % dashSize  == 0)
			flip = !flip;
        
		imageStore(image, steep ? ivec2(y, x) : ivec2(x, y), flip ? vec4(255, 255, 255, 255) : vec4(0, 0, 0, 255));			


        error -= abs(d.y);
        if (error < 0.0)
        {
            y += ystep;
            error += d.x;
        }
    }
}

bool pointInQuad(vec2 point, vec2 A, vec2 B, vec2 C, vec2 D)
{
    float minX = min(min(A.x, B.x), min(C.x, D.x));
    float maxX = max(max(A.x, B.x), max(C.x, D.x));
    float minY = min(min(A.y, B.y), min(C.y, D.y));
    float maxY = max(max(A.y, B.y), max(C.y, D.y));

    if (point.x < minX || point.x > maxX || point.y < minY || point.y > maxY)
    {
        return false;
    }

    bool signAB = cross(vec3(point - A, 0), vec3(B - A, 0)).z >= 0;
    bool signBC = cross(vec3(point - B, 0), vec3(C - B, 0)).z >= 0;
    bool signCD = cross(vec3(point - C, 0), vec3(D - C, 0)).z >= 0;
    bool signDA = cross(vec3(point - D, 0), vec3(A - D, 0)).z >= 0;
    return (signAB == signBC) && (signBC == signCD) && (signCD == signDA);
}

void main() 
{
	ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);
    
    if(doWarp)
    {
        float in_x = warp[0][0] * texelCoord.x + warp[0][1] * texelCoord.y + warp[0][2];
        float in_y = warp[1][0] * texelCoord.x + warp[1][1] * texelCoord.y + warp[1][2];
        float in_z = warp[2][0] * texelCoord.x + warp[2][1] * texelCoord.y + warp[2][2];

        int x_norm = int(in_x / in_z);
        int y_norm = int(in_y / in_z);
        
        if(pointInQuad(texelCoord, vec2(ps[0], ps[1]), vec2(ps[2], ps[3]), vec2(ps[4], ps[5]), vec2(ps[6], ps[7])))
        {
            imageStore(image, texelCoord, imageLoad(samplerImage, ivec2(x_norm, y_norm)));
        }
        else
        {
            imageStore(image, texelCoord, fillTransparent ? vec4(255, 255, 255, 0) : imageLoad(samplerImage, texelCoord));
        }
    }
    else
    {
        imageStore(image, texelCoord, imageLoad(samplerImage, texelCoord));
    }
    
    if(doLines)
    {
        if(texelCoord.x == 0 && texelCoord.y == 0)
        {
            drawLine(vec2(ps[0], ps[1]), vec2(ps[2], ps[3]));
            drawLine(vec2(ps[0], ps[1]), vec2(ps[6], ps[7]));
            drawLine(vec2(ps[2], ps[3]), vec2(ps[4], ps[5]));
            drawLine(vec2(ps[4], ps[5]), vec2(ps[6], ps[7]));         
        }
    }
}